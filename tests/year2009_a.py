"""Tests corresponding to the 2009 QSNMC competition, Challenge A."""

from __future__ import division

import sys

import numpy as np
import sciunit
import sciunit.scores
from neuronunit.capabilities import ProducesSpikes
from NeuroTools.signals import AnalogSignal
from NeuroTools.signals.spikes import SpikeTrain

from ..capabilities import TrainVoltageOnCurrent,load_training_data,load_testing_data
from ..comparators import SpikeTrainComparator

dt = 1e-4 # 10 kHz sampling. 

###################
# Available Tests #
###################

# Could be moved to neuronunit.tests.  

class SpikeTrainComparisonTest(sciunit.Test):
    """Compares spike trains for concordance of spike times."""

    def __init__(self,
                 observation={'current':None,'spike_trains':[]},
                 name="Spike train comparison test",
                 delta=1.0, 
                 T=None, 
                 method='Rect'):
        """
        observation['current']: a NeuroTools AnalogSignal corresponding to
                                    the injected current.    
        observation['spike_trains']: a list of spike trains, where each spike 
                                     train is a NeuroTools SpikeTrain.  
        delta: The window width for computing similarity (ms). 
        T: Spike count array will be generated by observed spike 
                     trains from 0 to T (ms).  Defaults to time of last spike 
                     across all spike trains.  
        method: 'Rect' or 'Kistler', corresponding to two methods for 
                          computing MDstar.  
        """

        dt = observation['current'].dt
        if T is None: # If no duration given.      
            T_max = 0
            for train in observation['spike_trains']:
                T_max = max(T_max,train.duration())
            T = T_max
        
        params = {'delta': delta, 'dt': dt, 'T':T, 'method': method}
        sciunit.Test.__init__(self,observation,name,**params)
        self.required_capabilities += (ProducesSpikes,)

    description = "A test of the similarity of spike trains."

    score_type = sciunit.scores.PercentScore

    def validate_observation(self, observation):
        try:
            assert type(observation) is dict, 'Observation must be a dict'
            assert type(observation['spike_trains']) is list, \
                "observation['spike_trains'] must be a list"
            for spike_train in observation['spike_trains']:
                assert type(spike_train) is SpikeTrain, \
                    "Each spike_train must be a NeuroTools SpikeTrain"
            assert type(observation['current']) is AnalogSignal, \
                "observation['current'] must be a NeuroTools AnalogSignal"
        except Exception:
            print("something bad happend")

    def generate_prediction(self, model):
        """Implementation of sciunit.Test.generate_prediction."""
        model.set_external_current(self.observation['current']) 
        model_spike_trains = model.get_spike_trains()
        prediction = {'spike_trains':model_spike_trains}
        return prediction

    def compute_score(self, observation, prediction):
        """Implementation of sciunit.Test.score_prediction."""
        observed = observation['spike_trains']
        predicted = prediction['spike_trains']
        T = self.params['T']
        comparator = SpikeTrainComparator(T,observed,predicted)
        comparator.compute = getattr(comparator,"computeMD_%s" % self.params['method'])
        delta = self.params['delta']
        dt = self.params['dt']
        MDstar = comparator.compute(delta, dt) 
        score = self.score_type(MDstar * 100.0)
        score.related_data.update(self.params)
        return score

####################
# Tests to execute #
####################

# Training data.
def get_observation(phase):
    if phase == 'training':
        load_data = load_training_data
    elif phase == 'testing':
        load_data = load_testing_data
    else:
        raise Exception("Phase must be 'training' or 'testing'")
    
    current_array,voltage_array = load_data()
    # Dataset specific, trunkade current_array to the length of the voltage_array.
    current_array = current_array[0:voltage_array.shape[0]]
    spike_trains = []
    gold_voltages = []

    for col in range(voltage_array.shape[1]):
        voltage_trial = voltage_array[:,col]
        gold_voltages.append(voltage_trial)

        vm_trial = AnalogSignal(voltage_trial,dt)
        spike_train = vm_trial.threshold_detection(0)
        spike_trains.append(spike_train)
    
    current = AnalogSignal(current_array,dt)
    observation = {'current':current,'spike_trains':spike_trains, 'gold_voltages': gold_voltages}

    return observation

training_observation = get_observation('training')
training = SpikeTrainComparisonTest(observation=training_observation,
                                    name="Test on Training Data")

tests = [training,]#test]

